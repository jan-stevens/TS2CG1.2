  #if !defined(AFX_SurfaceMap_CPP_9T4A21B7_C13C_1223_BF2E_124095086234__INCLUDED_)
#define AFX_SurfaceMap_CPP_9T4A21B7_C13C_1223_BF2E_124095086234__INCLUDED_

#include <stdio.h>
#include <math.h>
#include "SurfaceMap.h"
#include "GenerateUnitCells.h"
#include "Def.h"
#include "FlatPointMaker.h"
#include "Sphere.h"
#include "Cylinder.h"
#include "SHGeneric1DPBCPointMaker.h"
// Sept 2023,

SurfaceMap::SurfaceMap(Argument *pArgu)
{
    
    Nfunction f;

    
    m_monolayer = false;
    std::string dtsfolder = pArgu->GetDTSFolder();              // get the name of the folder generated by the PLM
    std::string strfilename = pArgu->GetStructureFileName();    // Get the stracture file name
    m_InclusionDirectionType = pArgu->GetInclusionDirectionType(); //Note: in the normal condition PLM always write global so only applicable if you want to change the point folder manually
//std::cout<<"The inclusion direction type is: "<<m_InclusionDirectionType<<"\n";

//================== Reading DTS folder to get the points ====================================================
    
    
    std::string function = pArgu->GetFunction();
    std::vector<point>  point1;
    std::vector<point>  point2;
    std::vector<point>  wpoint1;
    std::vector<point>  wpoint2;
    ReadDTSFolder ReadDTSFile(dtsfolder);

    if(function=="analytical_shape")
    {
        std::string ftype= functiontype(strfilename);
        Nfunction f;      // In this class there are some useful function and we can use it.
        

        if(ftype == "Flat")
        {
            std::cout<<"Flat bilayer will be made \n";
            FlatPointMaker  Fu(pArgu);
            point1 = Fu.GetUpPoint();
            point2 = Fu.GetInPoint();
            wpoint1  = Fu.GetWallPoint1();
            wpoint2  = Fu.GetWallPoint2();
            m_Box=Fu.GetBox();
            m_pBox =&m_Box;
        }
        else if(ftype == "1D_PBC_Fourier")
        {
            std::cout<<"shape from 1D_PBC_Fourier will be made \n";
            SHGeneric1DPBCPointMaker  Fu(pArgu);
            point1 = Fu.GetUpPoint();
            point2 = Fu.GetInPoint();
            wpoint1  = Fu.GetWallPoint1();
            wpoint2  = Fu.GetWallPoint2();
            m_Box=Fu.GetBox();
            m_pBox =&m_Box;
        }
        else if(ftype == "Sphere")
        {
            std::cout<<"vesicle will be made \n";
            Sphere  Fu(pArgu);
            point1 = Fu.GetUpPoint();
            point2 = Fu.GetInPoint();
            wpoint1  = Fu.GetWallPoint1();
            wpoint2  = Fu.GetWallPoint2();
            m_Box=Fu.GetBox();
            m_pBox =&m_Box;
        }
        else if(ftype == "Cylinder")
        {
            std::cout<<"vesicle will be made \n";
            Cylinder  Fu(pArgu);
            point1 = Fu.GetUpPoint();
            point2 = Fu.GetInPoint();
            wpoint1  = Fu.GetWallPoint1();
            wpoint2  = Fu.GetWallPoint2();
            m_Box=Fu.GetBox();
            m_pBox =&m_Box;
        }
        else
        {
            std::cout<<"-> aborted! ---> the shape defined in the str file is unknown :) \n";
            std::exit(0);
        }
        
        for ( std::vector<point>::iterator it = point1.begin(); it != point1.end(); it++ )
            m_point1.push_back(&(*it));
        
        for ( std::vector<point>::iterator it = point2.begin(); it != point2.end(); it++ )
            m_point2.push_back(&(*it));
        
    }
    else
    {

        m_pInc = ReadDTSFile.GetInclusion();
        m_pExc = ReadDTSFile.GetExclusion();

        m_point1 = ReadDTSFile.GetUpperPoints();
        m_point2 = ReadDTSFile.GetInnerPoints();
        
        Vec3D *pBox= ReadDTSFile.GetBox();
        m_Box (0)=(*pBox)(0);     m_Box (1)=(*pBox)(1);     m_Box (2)=(*pBox)(2);
        m_pBox = pBox;
        
    }
    //=============
    if(m_point2.size()==0)
    m_monolayer = true;

    //=============== make wall; Wall info and data

    Wall CWall = pArgu->GetWall();
    CWall.UpdateBox(m_pBox);
    
    if(function=="analytical_shape")
    {
        std::vector<point*> pp1,pp2;
        for (std::vector<point >::iterator it = wpoint1.begin() ; it != wpoint1.end(); ++it)
            pp1.push_back(&(*it));
        for (std::vector<point >::iterator it = wpoint2.begin() ; it != wpoint2.end(); ++it)
            pp2.push_back(&(*it));
    
    CWall.CreateWall(pp1,pp2);
    }
    else
    {
        CWall.CreateWall(m_point1,m_point2);
    }

    std::vector<bead> WB = CWall.GetWallBead();
    std::vector<point*> WPoint = CWall.GetWallPoint();
    
    
    
    //
    //std::vector<point>  wpoint1;
    //std::vector<point>  wpoint2;
    //==========  We write the wall at the end

    
    //********************** Finding the total area of the layers
    m_TotalAreaUp = 0.0;
    m_TotalAreaDown = 0.0;
    for ( std::vector<point*>::iterator it = m_point1.begin(); it != m_point1.end(); it++ )
        m_TotalAreaUp+= (*it)->GetArea();
    for ( std::vector<point*>::iterator it = m_point2.begin(); it != m_point2.end(); it++ )
        m_TotalAreaDown+= (*it)->GetArea();

    if(m_monolayer == false)
    std::cout<<"--> Note: the total upper monolayer area is "<<m_TotalAreaUp<<" and the total lower monolayer area is "<<m_TotalAreaDown<<"\n";
    else
    std::cout<<"--> Note: the total monolayer area is "<<m_TotalAreaUp<<" \n";

    

    
    //********* Lets exclude the points based on exclusion
    
    if(m_pExc.size()!=0)
    {
        std::cout<<" Note: we are excluding points based on exclusion, If it is slow, contact the developer \n";
        // m_pExc
        //m_point2
        
        for ( std::vector<exclusion*>::iterator it = m_pExc.begin(); it != m_pExc.end(); it++ )
        {
            int pointid=(*it)->GetPointID();
            if(pointid<0 || pointid>m_point1.size())
            std::cout<<"error 23456 \n";
            
            point *Up_p1=m_point1.at(pointid);
            Vec3D Pos = Up_p1->GetPos();
            Vec3D N = Up_p1->GetNormal();
            double R = (*it)->GetRadius();
            if(R!=0)
            Up_p1->UpdateArea(0);

            for ( std::vector<point*>::iterator it1 = m_point1.begin(); it1 != m_point1.end(); it1++ )
            {
                Vec3D Pos1 = (*it1)->GetPos();
                Vec3D DP = Pos1-Pos;
                double dist = DP.norm();
                Vec3D UnitDP =DP*(1/dist);
                double sinT = fabs((UnitDP*N).norm());
                double cosT = fabs(N.dot(UnitDP,N));

                if(dist*sinT<=R && dist*cosT<6)
                {
                    (*it1)->UpdateArea(0);

                }

                
            }
            for ( std::vector<point*>::iterator it1 = m_point2.begin(); it1 != m_point2.end(); it1++ )
            {
                Vec3D Pos1 = (*it1)->GetPos();
                Vec3D DP = Pos1-Pos;
                double dist = DP.norm();
                Vec3D UnitDP =DP*(1/dist);
                double sinT = fabs((UnitDP*N).norm());
                double cosT = fabs(N.dot(UnitDP,N));

                if(dist*sinT<=R && dist*cosT< 6)
                {
                    (*it1)->UpdateArea(0);
                    
                }
                
            }
            

        }

        
    }
    



    




}
SurfaceMap::~SurfaceMap()
{
    
}
double SurfaceMap::dist2between2Points(Vec3D X1,Vec3D X2)
{
    
    double dist2=0;
    
    double x1=X1(0);
    double y1=X1(1);
    double z1=X1(2);
    
    double x2=X2(0);
    double y2=X2(1);
    double z2=X2(2);
    
    
    double dx=x2-x1;
    double dy=y2-y1;
    double dz=z2-z1;
    
    if(fabs(dx)>(*m_pBox)(0)/2.0)
    {
        if(dx<0)
            dx=(*m_pBox)(0)+dx;
        else if(dx>0)
            dx=dx-(*m_pBox)(0);
    }
    if(fabs(dy)>(*m_pBox)(1)/2.0)
    {
        if(dy<0)
            dy=(*m_pBox)(1)+dy;
        else if(dy>0)
            dy=dy-(*m_pBox)(1);
    }
    if(fabs(dz)>(*m_pBox)(2)/2.0)
    {
        if(dz<0)
            dz=(*m_pBox)(2)+dz;
        else if(dz>0)
            dz=dz-(*m_pBox)(2);
    }

    dist2=dx*dx+dy*dy+dz*dz;
    return dist2;
}
Tensor2 SurfaceMap::Rz(double cos, double sin)
{
    Tensor2  R;
    
    R(0,0) = cos;
    R(0,1) = -sin;
    R(1,0) = sin;
    R(1,1) = cos;
    R(2,2) = 1;

    
    
    return R;
}
Tensor2  SurfaceMap::TransferMatLG(Vec3D Normal, Vec3D t1, Vec3D t2)
{
    Tensor2  GL(t1,t2,Normal);
    Tensor2 LG=GL.Transpose(GL);
    return LG;
    
}
std::string SurfaceMap::functiontype(std::string filename)
{
    std::string ftype;
    bool OK=true;
    Nfunction f;
    std::ifstream file;
    file.open(filename.c_str());
    bool flag = false;
    std::string str;
    
    while (true)
    {
        std::getline (file,str);
        if(file.eof())
            break;
        
        std::cout<<str<<"\n";
        std::vector<std::string> Line = f.split(str);
        if(Line.size()!=0 && (Line.at(0)).at(0)!=';')
        {
            if((Line.at(0)).at(0)=='[' && flag==false)
            {
                str = f.trim(str);
                str.erase(std::remove(str.begin(), str.end(), '['), str.end());
                str.erase(std::remove(str.begin(), str.end(), ']'), str.end());
                str.erase(std::remove(str.begin(), str.end(), ' '), str.end());
                
                if(str=="ShapeData")
                    flag = true;
            }
            else if((Line.at(0))=="End" && flag==true)
            {
                flag=false;
            }
            else if(flag==true && Line.at(0)=="ShapeType")
            {

                    if(Line.size()<2)
                        std::cout<<" Error: ShapeType information in the str file is not correct \n";
                    else
                    ftype = Line.at(1);
                
                break;

            }
            
            
        }
        
        
    }
    
    
    file.close();
    

    return ftype;
}






#endif



